# 设计模式

---

## 1.类之间的关系

* ### 泛化关系

  * 首先类的继承结构表现为**泛化**和**实现**，继承关系可以用is a来表示，也就是aa是bb这样的关系就叫继承关系。泛化是指aa在现实中有实现，距离：suv是小汽车，因此他们之间是泛化关系。在代码中，泛化关系可以表示为继承非抽象类。
  * ![_images/uml_generalize.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg)

* ### 实现关系

  * 接着上面所说，aa如果是抽象的，现实中没有实现的，那就是实现关系，比如自行车是一种车，那么此时aa就是车。代码中可以表现为继承抽象类。
  * ![_images/uml_realize.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg)

* ### 聚合关系

  * 表示整体由部分构成，比如一个部门由多个员工组成。其中**部门撤销了，人还在**
  * ![_images/uml_aggregation.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg)

* ### 组合关系

  * 和聚合关系不同的是，公司由多个部门组成。其中**公司解散了，部门也不存在了**。
  * ![_images/uml_composition.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg)

* ### 关联关系

  * 描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系。代码中表现为变量。
  * ![_images/uml_association.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg)

* ### 依赖关系

  * 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；
  * ![_images/uml_dependency.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg)



## 2.创建型模式

​	创建型模式主要是对类的实例化过程进行抽象，将对象的创建和使用分离。这样做可以让外界对于这些对象只需要知道他们共同的接口，而不需要清楚具体的细节，使整个系统更符合单一职责原则。

​	创建型模式在创建什么，由谁创建，何时创建等方面为软件设计者提供了灵活性。它隐藏类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。

* ### 简单工厂模式（4）

  简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

  简单工厂模式包含如下角色：

  * **Factory：工厂角色**

    工厂角色负责实现创建所有实例的内部逻辑

  * **Product：抽象产品角色**

    抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口

  * **ConcreteProduct：具体产品角色**

    具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

  ![../_images/SimpleFactory.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/SimpleFactory.jpg)

  * **缺点**：简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的，并且在工厂产品较多逻辑复杂时，难以维护。并且一旦工厂类出问题，整个系统都会受到影响。
  * **优点**：简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。引入配置文件即可不修改客户端代码实现更换和增加新的具体产品。

* ### 工厂方法模式（5）

  工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

  工厂方法模式包含如下角色：

  * **Product：抽象产品**

  * **ConcreteProduct：具体产品**

  * **Factory：抽象工厂**

  * **ConcreteFactory：具体工厂**

    ![../_images/FactoryMethod.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg)

  * **优点**：工厂方法模式是简单工厂的改进，引入了继承，核心的工厂类不再负责创建，而是交给子类去做，核心的工厂类只给出子类需要完成的接口，不具体实现。使得这个系统可以在不改变工厂类的前提下增加新的产品。
  * **缺点**：增加新的产品要编写具体产品类和与之对应的工厂类，代码复杂度提高，编译成本增加。并且考虑系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

* ### 抽象工厂模式（5）

  抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。

  抽象工厂模式包含如下角色：

  * **AbstractFactory：抽象工厂**
  * **ConcreteFactory：具体工厂**
  * **AbstractProduct：抽象产品**
  * **Product：具体产品**

  ![../_images/AbatractFactory.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg)

  * 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。
  * 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。
  * **优点**：抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象，尤其是在需要根据当前环境来决定其行为的软件系统上。
  * **缺点**：开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）

* ### 建造者模式（2）

  建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使同样的构建过程可以创建不同表示。

  建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。

  建造者模式包含如下角色：

  * Builder：抽象建造者
  * ConcreteBuilder：具体建造者
  * Director：指挥者
  * Product：产品角色

  ![../_images/Builder.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Builder.jpg)

  * **优点**：客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， **用户使用不同的具体建造者即可得到不同的产品对象**。
  * **缺点**：开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）

* ### 原型模式（3）

* ### 单例模式（4）

  * 对于系统中的某些类来说，只有一个实例很重要，比如操作系统中只能有一个正在打印的任务，只能有一个窗口管理器或文件系统，因此就需要单例模式，这个类可以保证没有其他实例被创建，并对外提供一个访问该实例的方法。

  * 单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

    单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。

    ![../_images/Singleton.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/Singleton.jpg)

  * **优点**：提供对唯一实例的受控访问，严格控制访问条件和时机。

  * **缺点**：扩展比较难，违背了单一职责原则，同时滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。

